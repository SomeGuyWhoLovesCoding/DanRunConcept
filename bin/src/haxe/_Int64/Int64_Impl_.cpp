// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_38344beec7696400
#define INCLUDED_38344beec7696400
#include "cpp/Int64.h"
#endif
#ifndef INCLUDED_haxe_Int64Helper
#include <haxe/Int64Helper.h>
#endif
#ifndef INCLUDED_haxe__Int64_Int64_Impl_
#include <haxe/_Int64/Int64_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_3debe8910def42a5_193_fromFloat,"haxe._Int64.Int64_Impl_","fromFloat",0xa3d45c39,"haxe._Int64.Int64_Impl_.fromFloat","C:\\HaxeToolkit\\haxe\\std/cpp/_std/haxe/Int64.hx",193,0x97dcebb4)
HX_LOCAL_STACK_FRAME(_hx_pos_3debe8910def42a5_196_divMod,"haxe._Int64.Int64_Impl_","divMod",0x9975972a,"haxe._Int64.Int64_Impl_.divMod","C:\\HaxeToolkit\\haxe\\std/cpp/_std/haxe/Int64.hx",196,0x97dcebb4)
namespace haxe{
namespace _Int64{

void Int64_Impl__obj::__construct() { }

Dynamic Int64_Impl__obj::__CreateEmpty() { return new Int64_Impl__obj; }

void *Int64_Impl__obj::_hx_vtable = 0;

Dynamic Int64_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Int64_Impl__obj > _hx_result = new Int64_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Int64_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x66145239;
}

::cpp::Int64 Int64_Impl__obj::fromFloat(Float f){
            	HX_STACKFRAME(&_hx_pos_3debe8910def42a5_193_fromFloat)
HXDLIN( 193)		return ::haxe::Int64Helper_obj::fromFloat(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int64_Impl__obj,fromFloat,return )

 ::Dynamic Int64_Impl__obj::divMod(::cpp::Int64 dividend,::cpp::Int64 divisor){
            	HX_STACKFRAME(&_hx_pos_3debe8910def42a5_196_divMod)
HXLINE( 197)		if (_hx_int64_is_zero(divisor)) {
HXLINE( 197)			HX_STACK_DO_THROW(HX_("divide by zero",6a,d2,eb,57));
            		}
HXDLIN( 197)		::cpp::Int64 q = _hx_int64_div(dividend,divisor);
HXLINE( 199)		if (_hx_int64_eq(divisor,( (::cpp::Int64)(0) ))) {
HXLINE( 200)			HX_STACK_DO_THROW(HX_("divide by zero",6a,d2,eb,57));
            		}
HXLINE( 202)		::cpp::Int64 m = _hx_int64_sub(dividend,_hx_int64_mul(q,divisor));
HXLINE( 204)		return  ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("quotient",ab,68,60,b2),q)
            			->setFixed(1,HX_("modulus",37,f0,fa,f7),m));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int64_Impl__obj,divMod,return )


Int64_Impl__obj::Int64_Impl__obj()
{
}

bool Int64_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"divMod") ) { outValue = divMod_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromFloat") ) { outValue = fromFloat_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Int64_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Int64_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Int64_Impl__obj::__mClass;

static ::String Int64_Impl__obj_sStaticFields[] = {
	HX_("fromFloat",d2,af,1f,b7),
	HX_("divMod",f1,f9,fc,be),
	::String(null())
};

void Int64_Impl__obj::__register()
{
	Int64_Impl__obj _hx_dummy;
	Int64_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe._Int64.Int64_Impl_",15,d6,6c,a0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Int64_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Int64_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Int64_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Int64_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Int64_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace _Int64

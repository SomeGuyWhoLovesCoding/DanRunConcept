// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_stuff_CookingPanRGB
#include <stuff/CookingPanRGB.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_26b66973bb7f9f1b_9_new,"stuff.CookingPanRGB","new",0x18a3ce42,"stuff.CookingPanRGB.new","stuff/CookingPanRGB.hx",9,0xab3e016f)
HX_LOCAL_STACK_FRAME(_hx_pos_26b66973bb7f9f1b_15_Random,"stuff.CookingPanRGB","Random",0x7f91f181,"stuff.CookingPanRGB.Random","stuff/CookingPanRGB.hx",15,0xab3e016f)
namespace stuff{

void CookingPanRGB_obj::__construct(::hx::Null< int >  __o_b,::hx::Null< int >  __o_l,::hx::Null< int >  __o_r){
            		int b = __o_b.Default(858993663);
            		int l = __o_l.Default(-13369345);
            		int r = __o_r.Default(-16776961);
            	HX_STACKFRAME(&_hx_pos_26b66973bb7f9f1b_9_new)
HXLINE(  10)		this->black = b;
HXLINE(  11)		this->lime = l;
HXLINE(  12)		this->red = r;
            	}

Dynamic CookingPanRGB_obj::__CreateEmpty() { return new CookingPanRGB_obj; }

void *CookingPanRGB_obj::_hx_vtable = 0;

Dynamic CookingPanRGB_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CookingPanRGB_obj > _hx_result = new CookingPanRGB_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool CookingPanRGB_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x03a6b602;
}

 ::stuff::CookingPanRGB CookingPanRGB_obj::Random(){
            	HX_GC_STACKFRAME(&_hx_pos_26b66973bb7f9f1b_15_Random)
HXLINE(  17)		 ::Dynamic alpha = ::Math_obj::floor((::Math_obj::random() * ( (Float)(255) )));
HXDLIN(  17)		int newCPR;
HXDLIN(  17)		if (::hx::IsNull( alpha )) {
HXLINE(  17)			int newCPR1 = (::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(256) ))) << 24);
HXDLIN(  17)			newCPR = (newCPR1 | ::Std_obj::random(16777216));
            		}
            		else {
HXLINE(  17)			int newCPR2 = (::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(256) ))) << 24);
HXDLIN(  17)			newCPR = ((newCPR2 | (::Std_obj::random(65536) << 8)) | ( (int)(alpha) ));
            		}
HXLINE(  18)		 ::Dynamic alpha1 = ::Math_obj::floor((::Math_obj::random() * ( (Float)(255) )));
HXDLIN(  18)		int newCPR3;
HXDLIN(  18)		if (::hx::IsNull( alpha1 )) {
HXLINE(  18)			int newCPR4 = (::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(256) ))) << 24);
HXDLIN(  18)			newCPR3 = (newCPR4 | ::Std_obj::random(16777216));
            		}
            		else {
HXLINE(  18)			int newCPR5 = (::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(256) ))) << 24);
HXDLIN(  18)			newCPR3 = ((newCPR5 | (::Std_obj::random(65536) << 8)) | ( (int)(alpha1) ));
            		}
HXLINE(  19)		 ::Dynamic alpha2 = ::Math_obj::floor((::Math_obj::random() * ( (Float)(255) )));
HXDLIN(  19)		int newCPR6;
HXDLIN(  19)		if (::hx::IsNull( alpha2 )) {
HXLINE(  19)			int newCPR7 = (::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(256) ))) << 24);
HXDLIN(  19)			newCPR6 = (newCPR7 | ::Std_obj::random(16777216));
            		}
            		else {
HXLINE(  19)			int newCPR8 = (::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(256) ))) << 24);
HXDLIN(  19)			newCPR6 = ((newCPR8 | (::Std_obj::random(65536) << 8)) | ( (int)(alpha2) ));
            		}
HXLINE(  16)		 ::stuff::CookingPanRGB newCPR9 =  ::stuff::CookingPanRGB_obj::__alloc( HX_CTX ,newCPR,newCPR3,newCPR6);
HXLINE(  21)		int this1 = newCPR9->black;
HXDLIN(  21)		if ((::Math_obj::round((( (Float)(((((this1 >> 24) & 255) + ((this1 >> 16) & 255)) + ((this1 >> 8) & 255))) ) / ( (Float)(3) ))) < 40)) {
HXLINE(  21)			newCPR9->black = ((((newCPR9->black & 255) | 671088640) | 2621440) | 10240);
            		}
HXLINE(  22)		int this2 = newCPR9->black;
HXDLIN(  22)		if ((::Math_obj::round((( (Float)(((((this2 >> 24) & 255) + ((this2 >> 16) & 255)) + ((this2 >> 8) & 255))) ) / ( (Float)(3) ))) > 60)) {
HXLINE(  22)			newCPR9->black = ((((newCPR9->black & 255) | 335544320) | 1310720) | 5120);
            		}
HXLINE(  23)		int this3 = newCPR9->lime;
HXDLIN(  23)		if ((::Math_obj::round((( (Float)(((((this3 >> 24) & 255) + ((this3 >> 16) & 255)) + ((this3 >> 8) & 255))) ) / ( (Float)(3) ))) > 60)) {
HXLINE(  23)			newCPR9->lime = ((((newCPR9->lime & 255) | (int)1006632960) | 3932160) | 15360);
            		}
HXLINE(  24)		{
HXLINE(  24)			int a = ::Std_obj::_hx_int((((( (Float)((newCPR9->black & 255)) ) / ( (Float)(255) )) * ((Float).9)) * ( (Float)(255) )));
HXDLIN(  24)			newCPR9->black = ((newCPR9->black & -256) | a);
            		}
HXLINE(  25)		{
HXLINE(  25)			int a1 = ::Std_obj::_hx_int((((( (Float)((newCPR9->lime & 255)) ) / ( (Float)(255) )) * ((Float).9)) * ( (Float)(255) )));
HXDLIN(  25)			newCPR9->lime = ((newCPR9->lime & -256) | a1);
            		}
HXLINE(  26)		{
HXLINE(  26)			int this4 = newCPR9->red;
HXDLIN(  26)			int lum = (::Math_obj::round((( (Float)(((((this4 >> 24) & 255) + ((this4 >> 16) & 255)) + ((this4 >> 8) & 255))) ) / ( (Float)(3) ))) + (newCPR9->red & 255));
HXDLIN(  26)			newCPR9->red = ((((newCPR9->red & 255) | (lum << 24)) | (lum << 16)) | (lum << 8));
            		}
HXLINE(  27)		{
HXLINE(  27)			int a2 = 255;
HXDLIN(  27)			newCPR9->red = ((newCPR9->red & -256) | a2);
            		}
HXLINE(  28)		return newCPR9;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(CookingPanRGB_obj,Random,return )


CookingPanRGB_obj::CookingPanRGB_obj()
{
}

::hx::Val CookingPanRGB_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"red") ) { return ::hx::Val( red ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"lime") ) { return ::hx::Val( lime ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"black") ) { return ::hx::Val( black ); }
	}
	return super::__Field(inName,inCallProp);
}

bool CookingPanRGB_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"Random") ) { outValue = Random_dyn(); return true; }
	}
	return false;
}

::hx::Val CookingPanRGB_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"red") ) { red=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"lime") ) { lime=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"black") ) { black=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CookingPanRGB_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("black",bf,d5,f1,b4));
	outFields->push(HX_("lime",15,17,b3,47));
	outFields->push(HX_("red",51,d9,56,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo CookingPanRGB_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(CookingPanRGB_obj,black),HX_("black",bf,d5,f1,b4)},
	{::hx::fsInt,(int)offsetof(CookingPanRGB_obj,lime),HX_("lime",15,17,b3,47)},
	{::hx::fsInt,(int)offsetof(CookingPanRGB_obj,red),HX_("red",51,d9,56,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *CookingPanRGB_obj_sStaticStorageInfo = 0;
#endif

static ::String CookingPanRGB_obj_sMemberFields[] = {
	HX_("black",bf,d5,f1,b4),
	HX_("lime",15,17,b3,47),
	HX_("red",51,d9,56,00),
	::String(null()) };

::hx::Class CookingPanRGB_obj::__mClass;

static ::String CookingPanRGB_obj_sStaticFields[] = {
	HX_("Random",23,96,23,ec),
	::String(null())
};

void CookingPanRGB_obj::__register()
{
	CookingPanRGB_obj _hx_dummy;
	CookingPanRGB_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("stuff.CookingPanRGB",50,45,53,1e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &CookingPanRGB_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(CookingPanRGB_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(CookingPanRGB_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< CookingPanRGB_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CookingPanRGB_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CookingPanRGB_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace stuff
